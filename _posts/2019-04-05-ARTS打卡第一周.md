---
layout:     post
title:      ARTS打卡第一周
subtitle:   来嘛，英雄
date:       2019-04-05
author:     Gaolujie
header-img: img/post-bg-cook.jpg
catalog: true
tags:
    - LeetCode
    - C++
    - ARTS
---

### Algorithm

&emsp;&emsp;虽然之前就听说过LeetCode，但一直没有信心在上面刷题，在网上查了一下，大概有1000道题左右，分为Easy, Medium, Hard三个难度等级，既然耗子哥提要求了，那只能硬着头皮上了。  
&emsp;&emsp;新手嘛，必须从简入难，于是找了两道Easy的题，分别是Two Sum和Reverse Integer。有一点收获就是看了Two Sum里的Solution有很多利用hash\_map来做的，确实是机智，我的方法是先排序，然后移动头尾指针，来找到符合条件的两个数字，比较麻烦的是还要维护排好序的队列的索引值和原队列的索引，而且时间复杂度为O(nlgn)，也要比利用hash\_map的O(n)慢。做完了两道Easy的题，感觉还可以，想着给耗子哥交作业，也不能拿Easy的题来将就，那就选一道Medium（Hard的还是木有信心挑战）的吧，从上到下，选了第二道Add Two Numbers，这个也没什么难度，感觉主要考察的是对链表的运用和对边界问题的考虑。  
&emsp;&emsp;代码很简单，而且还有很多重复代码，等待改进。

#### 代码如下(C++)

    
		class Solution {
		public:
    		ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
    			ListNode *ret = NULL, *pos = NULL;
    			int carry = 0;
    			while (l1 != NULL && l2 != NULL)
    			{
    				int result = l1->val + l2->val + carry;
    				if (result >= 10)
    				{
    					result = result % 10;
    					carry = 1;
    				}
    				else 
    				carry = 0;
    				ListNode* node = new ListNode(result);
    				if (ret == NULL) {ret = node; pos = ret;}
    				else
    				{
    					pos->next = node;
    					pos = pos->next;
    				}
    				l1 = l1->next;
    				l2 = l2->next;
    			}
    			ListNode *remain = NULL;
    			if (l1 != NULL) remain = l1;
    			else remain = l2;
    			while (remain != NULL)
    			{
    				int result = carry + remain->val;
    				if (result >= 10)
    				{
    					result = result % 10;
    					carry = 1;
    				}
    				else 
    					carry = 0;
    				ListNode* node = new ListNode(result);
    				pos->next = node;
    				pos = pos->next;
    				remain = remain->next;
    			}
    			if (carry == 1)
    			{
    				ListNode* node = new ListNode(1);
    				pos->next = node;
    				pos = pos->next;
    			}
    			return ret;
    	  }
    };
        

#### 运行结果
虽然代码很简陋，但是运行结果还是很让人欣慰啊(苦笑)
![RuningResult](http://github.com/gaolujie365/gaolujie365.github.io/raw/master/img/2019/AddTwoNumbersRunningResult.jpg)


### Review




### Tip



### Share

&emsp;&emsp;前一段时间一直在研究[陈硕](https://github.com/chenshuo)的[muduo](https://github.com/chenshuo/muduo)网络库，因为之前做过高并发的服务器引擎，当时是用了公司内部开发的协程库，协程属于轻量级的线程，可以轻松的在一个进程里开出成千上万的协程来，而且避免了多线程的资源竞争，同步等问题，所以开发起来还是比较容易的。而muduo网络库主要使用了IO多路复用与多线程相结合的方式，以one loop per thread的方式来实现高并发，当然针对计算密集型的应用也可以使用one loop multi thread的方式，而且陈硕对于网络的操作封装的相当完美，以c++11里的std::function、std::bind的方式来实现回调函数的注册与使用。无论对于工程开发还是程序员的进阶学习都是很好的资源。奇虎360也开源了一个高并发网络库[evpp](https://github.com/Qihoo360/evpp)。其中也深度借鉴的muduo的设计理念，有时间大家也可以研究一下。

